
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [收益 & 成本](#收益--成本)
  - [收益](#收益)
  - [成本](#成本)
- [场景](#场景)
- [缓存更新策略](#缓存更新策略)
  - [1. LRU、LFU、FIFO etc算法剔除](#1-lrulfufifo-etc算法剔除)
  - [2. 超时剔除](#2-超时剔除)
  - [3. 主动更新](#3-主动更新)
- [粒度控制](#粒度控制)
- [面试常考](#面试常考)
  - [缓存穿透](#缓存穿透)
  - [缓存雪崩](#缓存雪崩)
  - [无底洞问题](#无底洞问题)
  - [热点Key的重建优化](#热点key的重建优化)

<!-- /code_chunk_output -->

# 收益 & 成本
## 收益
1. 加速读写
2. 降低后端负载
## 成本
1. 数据不一致
2. 代码维护成本
3. 运维成本
# 场景
1. 降低后端负载
2. 加速请求响应
3. 大量写合并为批量写
# 缓存更新策略
    缓存中的数据都是有生命周期的，需要在某短时间后被淘汰或更新，保障业务的同时保证缓存空间占用可控。
    
    缓存中的数据会和数据源中的真实数据有一段时间窗口的不一致，需要使用某些策略更新。

## 1. LRU、LFU、FIFO etc算法剔除
## 2. 超时剔除
## 3. 主动更新
# 粒度控制

# 面试常考
## 缓存穿透
## 缓存雪崩
## 无底洞问题
## 热点Key的重建优化